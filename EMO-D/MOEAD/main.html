<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Visualizador MOEA/D</title>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
    form { margin-bottom: 20px; }
    #plot, #hv-plot, #history-plot, #plot3d { width: 90%; margin: auto; }
    #plot { height: 600px; }
    #hv-plot { height: 400px; margin-top: 40px; }
    #history-plot { height: 500px; margin-top: 40px; }
    #plot3d { height: 600px; margin-top: 50px; }
    #slider-container { margin-top: 12px; width: 100%; }
    #slider { width: 100%; }
    #stats-container { white-space: pre; text-align:left; font-family: monospace; margin:10px auto 0; width:90%; display:none; }
    button, label { margin: 5px; padding: 8px 15px; }
  </style>
</head>
<body>
  <h1>Visualizador MOEA/D</h1>
  <form id="form">
    <div style="margin-bottom: 10px;">
      <label style="margin-right: 10px;">Instancia:
        <select name="instancia" style="margin-right: 20px;">
          <option value="DRP.dat">DRP.dat</option>
          <option value="100-3.dat">100-3.dat</option>
          <option value="150-11.dat">150-11.dat</option>
          <option value="1000-88_4.dat">1000-88_4.dat</option>
          <option value="1450-71_4.dat">1450-71_4.dat</option>
        </select>
      </label>

      <label style="margin-right: 10px;">Semilla:
        <input name="semilla" value="123" style="margin-right: 20px;">
      </label>

      <label style="margin-right: 10px;">Variables:
        <select name="num_var" style="margin-right: 20px;">
          <option value="21">21</option>
          <option value="100">100</option>
          <option value="150">150</option>
          <option value="1000">1000</option>
          <option value="1450">1450</option>
        </select>
      </label>

      <button type="submit">Ejecutar</button>
    </div>
  </form>

  <button id="load-btn">Cargar generaciones existentes</button>
  <label><input type="checkbox" id="fix-scale"> Usar la misma escala para comparar</label>
  <label><input type="checkbox" id="recalcular-hv" checked>Recalcular hipervolumen al cargar</label>

  <h3 id="status">Esperando ejecución...</h3>

  <div id="pareto-map-wrapper" style="display: flex; justify-content: center; align-items: flex-start; gap: 20px; margin-top: 20px;">
    <!-- Columna izquierda: gráfico + stats + slider -->
    <div style="width: 60%; min-width: 400px; display: flex; flex-direction: column; align-items: center;">
      <div id="plot" style="width: 100%; min-width: 400px;"></div>

      <!-- Stats debajo del gráfico -->
      <div id="stats-container"></div>

      <!-- Slider debajo de stats -->
      <div id="slider-container" style="display:none;">
        <input type="range" id="slider" min="0" max="0" value="0">
        <p>Generación: <span id="gen-num">1</span></p>
      </div>
    </div>

    <!-- Columna derecha: mapa -->
    <div id="map-container" style="display: none; width: 40%; min-width: 300px;">
      <h3>Configuración seleccionada:</h3>
      <img id="map-image" src="" alt="Mapa" style="width: 100%; border: 1px solid #ccc;">
    </div>
  </div>

  <div id="hv-plot"></div>
  <div id="history-plot"></div>

  <!-- Nuevo gráfico 3D -->
  <div id="plot3d"></div>

  <!-- Controles de visualización 3D/2D -->
  <div id="plot3d-controls" style="width:90%; margin:10px auto 0; display:flex; gap:8px; align-items:center; justify-content:flex-start;">
    <strong style="margin-right:6px;">Vista:</strong>
    <button type="button" id="btn-mode-3d">3D</button>
    <button type="button" id="btn-mode-2d-single">2D (una vista)</button>
    <select id="select-2d-proj" style="display:none;">
      <option value="f1f2">f1 vs f2</option>
      <option value="f1cov">f1 vs % cobertura</option>
      <option value="f2cov">f2 vs % cobertura</option>
    </select>
    <button type="button" id="btn-mode-2d-grid">2D (tres vistas)</button>
  </div>

  <!-- 2D: una sola vista -->
  <div id="plot2d" style="width:90%; height:520px; margin:12px auto 0; display:none;"></div>

  <!-- 2D: grilla de tres vistas -->
  <div id="plot2d-grid" style="width:90%; margin:12px auto 0; display:none; grid-template-columns: repeat(3, 1fr); gap:12px;">
    <div id="plot2d-f1f2" style="height:380px;"></div>
    <div id="plot2d-f1cov" style="height:380px;"></div>
    <div id="plot2d-f2cov" style="height:380px;"></div>
  </div>

  <script>
    const form = document.getElementById("form");
    const status = document.getElementById("status");
    const plotDiv = document.getElementById("plot");
    const sliderContainer = document.getElementById("slider-container");
    const slider = document.getElementById("slider");
    const genNum = document.getElementById("gen-num");
    const loadBtn = document.getElementById("load-btn");
    const fixScaleCheckbox = document.getElementById("fix-scale");

    let frames = [];
    let hvValues = [];
    let globalXMin = Infinity, globalXMax = -Infinity;
    let globalYMin = Infinity, globalYMax = -Infinity;

    let globalCovMin = Infinity, globalCovMax = -Infinity;

    // Estado de la vista final
    let viewMode = "3d";        // "3d" | "2d-single" | "2d-grid"
    let viewProj = "f1f2";      // para "2d-single": "f1f2" | "f1cov" | "f2cov"


    function findParetoFront(points) {
      if (!points || !Array.isArray(points) || points.length === 0) return [];
      const isDominated = new Array(points.length).fill(false);
      for (let i = 0; i < points.length; i++) {
        for (let j = 0; j < points.length; j++) {
          if (i !== j) {
            if (points[j].x <= points[i].x && points[j].y <= points[i].y &&
                (points[j].x < points[i].x || points[j].y < points[i].y)) {
              isDominated[i] = true;
              break;
            }
          }
        }
      }
      return points.map((p, i) => ({ ...p, isPareto: !isDominated[i] }));
    }

    function getMultiColor(factor) {
      const gradientColors = ["#440154", "#3b528b", "#21918c", "#fde725", "#ff7f00"];
      const scaled = factor * (gradientColors.length - 1);
      const idx1 = Math.floor(scaled);
      const idx2 = Math.min(idx1 + 1, gradientColors.length - 1);
      const localFactor = scaled - idx1;
      const c1 = gradientColors[idx1].slice(1);
      const c2 = gradientColors[idx2].slice(1);
      const r1 = parseInt(c1.slice(0, 2), 16), g1 = parseInt(c1.slice(2, 4), 16), b1 = parseInt(c1.slice(4), 16);
      const r2 = parseInt(c2.slice(0, 2), 16), g2 = parseInt(c2.slice(2, 4), 16), b2 = parseInt(c2.slice(4), 16);
      const r = Math.round(r1 + localFactor * (r2 - r1));
      const g = Math.round(g1 + localFactor * (g2 - g1));
      const b = Math.round(b1 + localFactor * (b2 - b1));
      return `rgb(${r},${g},${b})`;
    }

    async function loadGenerations(files, hvs) {
      frames = [];
      hvValues = hvs;
      globalXMin = Infinity; globalXMax = -Infinity;
      globalYMin = Infinity; globalYMax = -Infinity;

      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const res = await fetch("/get/" + file);
        const text = await res.text();

        const puntos = text
          .trim()
          .split("\n")
          .map(l => l.trim())
          .filter(l => l && !l.startsWith("#"))
          .map(line => {
            // separar cobertura si viene con '|'
            let coverage = null;
            let left = line;
            if (line.includes("|")) {
              const parts = line.split("|");
              left = parts[0].trim();
              const covStr = parts[1].trim().split(/\s+/)[0];
              const covVal = parseFloat(covStr);
              if (!Number.isNaN(covVal)) coverage = covVal;
            }

            const toks = left.split(/\s+/);
            const f1 = parseFloat(toks[0]);
            const f2 = parseFloat(toks[1]);

            let startIdx = 2;
            let isPareto;
            if (Number.isNaN(parseFloat(toks[2]))) {
              if (toks[2] === "P") { isPareto = true;  startIdx = 3; }
              else if (toks[2] === "D") { isPareto = false; startIdx = 3; }
              else if (toks[2] === "-" && line.includes("IDs instalados:")) {
                const right = line.split("IDs instalados:")[1] || "";
                const ids = right.trim().split(/\s+/).map(Number).filter(n => !Number.isNaN(n));
                updateRanges(f1, f2);
                return { x: f1, y: f2, ids, isPareto, coverage };
              }
            }

            const ids = toks.slice(startIdx).map(n => parseInt(n, 10)).filter(n => !Number.isNaN(n));

            updateRanges(f1, f2);

            if (typeof coverage === "number" && !Number.isNaN(coverage)) {
              if (coverage < globalCovMin) globalCovMin = coverage;
              if (coverage > globalCovMax) globalCovMax = coverage;
            }

            return { x: f1, y: f2, ids, isPareto, coverage };
          });

        frames.push(puntos);
      }

      showGeneration(0);
      sliderContainer.style.display = "block";
      slider.max = frames.length - 1;
      slider.value = 0;
      genNum.innerText = 1;
      status.innerText = `Listo: ${frames.length} generaciones cargadas`;

      Plotly.newPlot("hv-plot", [{
        x: hvValues.map((_, i) => i + 1),
        y: hvValues,
        mode: "lines+markers",
        marker: { color: "green" },
        line: { color: "green" },
        name: "Hipervolumen"
      }], {
        title: "Evolución del Hipervolumen",
        xaxis: { title: "Generación" },
        yaxis: { title: "Hipervolumen" }
      });

      document.getElementById("hv-plot").on("plotly_click", function(data) {
        const gen = data.points[0].x;
        slider.value = gen - 1;
        genNum.innerText = gen;
        showGeneration(gen - 1);
      });

      // Historial de frentes (solo Pareto por generación)
      const traces = frames.map((points, idx) => {
        const hasFlag = points.every(p => typeof p.isPareto === "boolean");
        const allPoints = hasFlag ? points : findParetoFront(points);
        const paretoPoints = allPoints.filter(p => p.isPareto);
        const color = getMultiColor(idx / Math.max(1, (frames.length - 1)));
        return {
          x: paretoPoints.map(p => p.x),
          y: paretoPoints.map(p => p.y),
          mode: "markers",
          marker: { size: 6, color: color },
          name: `Gen ${idx + 1}`,
          showlegend: false
        };
      });

      Plotly.newPlot("history-plot", traces, {
        title: "Historial de Frentes de Pareto",
        xaxis: { title: "f1" },
        yaxis: { title: "f2" }
      });

      function updateRanges(f1, f2) {
        if (f1 < globalXMin) globalXMin = f1;
        if (f1 > globalXMax) globalXMax = f1;
        if (f2 < globalYMin) globalYMin = f2;
        if (f2 > globalYMax) globalYMax = f2;
      }
    }

    function showGeneration(index) {
      const points = frames[index];
      if (!points || !Array.isArray(points)) return;

      // Si el archivo trae banderas P/D, úsalo; si no, calcula
      const hasFlag = points.every(p => typeof p.isPareto === "boolean");
      const allPoints = hasFlag ? points : findParetoFront(points);

      const paretoPoints = allPoints.filter(p => p.isPareto);
      const dominatedPoints = allPoints.filter(p => !p.isPareto);

      const layout = {
        title: `Frente de Pareto - Generación ${index + 1}`,
        xaxis: { title: "Minimizar Cobertura Probabilística (f1)" },
        yaxis: { title: "Minimizar Costos (f2)" },
        legend: {
          x: 1, y: 1, xanchor: 'right', yanchor: 'top',
          bgcolor: 'rgba(255,255,255,0.8)', bordercolor: '#ccc', borderwidth: 1
        }
      };

      if (fixScaleCheckbox.checked) {
        const xMargin = (globalXMax - globalXMin) * 0.05;
        const yMargin = (globalYMax - globalYMin) * 0.05;
        layout.xaxis.range = [globalXMin - xMargin, globalXMax + xMargin];
        layout.yaxis.range = [globalYMin - yMargin, globalYMax + yMargin];
      }

      Plotly.react(plotDiv, [
        {
          x: dominatedPoints.map(p => p.x),
          y: dominatedPoints.map(p => p.y),
          text: dominatedPoints.map(p => `IDs: ${p.ids.join(", ")}`),
          customdata: dominatedPoints.map(p => p.ids),
          mode: "markers",
          marker: { size: 8, color: "blue" },
          name: "Dominados",
          showlegend: true
        },
        {
          x: paretoPoints.map(p => p.x),
          y: paretoPoints.map(p => p.y),
          text: paretoPoints.map(p => `IDs: ${p.ids.join(", ")}`),
          customdata: paretoPoints.map(p => p.ids),
          mode: "markers",
          marker: { size: 10, color: "red", symbol: "circle-open" },
          name: "Frente Pareto",
          showlegend: true
        }
      ], layout);

      // también actualizar 3D
      drawFinalViews(allPoints, index);

      plotDiv.removeAllListeners?.('plotly_click');
      plotDiv.on('plotly_click', async function(data) {
        const idsSeleccionados = data.points[0].customdata || [];
        const instanciaActual = form.instancia.value;

        const res = await fetch("/map", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ instancia: instanciaActual, ids: idsSeleccionados })
        });

        if (res.ok) {
          const json = await res.json();
          const imgURL = "data:image/png;base64," + json.img;

          document.getElementById("map-image").src = imgURL;
          document.getElementById("map-container").style.display = "block";

          const statsDiv = document.getElementById("stats-container");
          statsDiv.textContent = json.stats;
          statsDiv.style.display = "block";
        } else {
          alert("❌ No se pudo generar el mapa.");
        }
      });
    }

    function draw3D(points, index) {
      // Si no hay cobertura en el archivo, no dibujar (o poner 0)
      const x = [], y = [], z = [], text = [];
      for (const p of points) {
        if (typeof p.coverage === "number" && !Number.isNaN(p.coverage)) {
          x.push(p.x); y.push(p.y); z.push(p.coverage);
          text.push(`IDs: ${p.ids.join(", ")}<br>Cobertura: ${p.coverage.toFixed(2)}%`);
        }
      }

      const trace = {
        x, y, z,
        mode: 'markers',
        type: 'scatter3d',
        marker: {
          size: 4,
          color: z,
          colorscale: 'Viridis',
          colorbar: { title: '% Cobertura' },
          opacity: 0.9
        },
        text
      };

      const layout3d = {
        title: `Frente de Pareto 3D - Gen ${index + 1}`,
        scene: {
          xaxis: { title: 'f1' },
          yaxis: { title: 'f2' },
          zaxis: { title: '% Cobertura' }
        },
        margin: { l: 0, r: 0, b: 0, t: 40 }
      };

      Plotly.react('plot3d', [trace], layout3d);
    }

    slider.addEventListener("input", () => {
      const index = parseInt(slider.value);
      genNum.innerText = index + 1;
      showGeneration(index);
    });

    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      status.innerText = "Ejecutando MOEA/D...";
      const data = {
        instancia: form.instancia.value,
        semilla: form.semilla.value,
        num_var: form.num_var.value
      };
      const res = await fetch("/run", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data)
      });
      const json = await res.json();
      if (!json.files || json.files.length === 0) {
        status.innerText = "⚠️ No se generaron archivos.";
        return;
      }
      await loadGenerations(json.files, json.hv || []);
    });

    loadBtn.addEventListener("click", async () => {
      status.innerText = "Cargando generaciones existentes...";
      const data = {
        instancia: form.instancia.value,
        semilla: form.semilla.value,
        recalcular: document.getElementById("recalcular-hv").checked
      };
      const res = await fetch("/load", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data)
      });
      const json = await res.json();
      if (!json.files || json.files.length === 0) {
        status.innerText = "⚠️ No se encontraron generaciones guardadas.";
        return;
      }
      await loadGenerations(json.files, json.hv || []);
    });

    fixScaleCheckbox.addEventListener("change", () => {
      showGeneration(parseInt(slider.value));
    });

    function drawFinalViews(points, index) {
      const plot3d = document.getElementById("plot3d");
      const plot2d = document.getElementById("plot2d");
      const grid = document.getElementById("plot2d-grid");
      const selectProj = document.getElementById("select-2d-proj");

      if (viewMode === "3d") {
        plot3d.style.display = "block";
        plot2d.style.display = "none";
        grid.style.display = "none";
        selectProj.style.display = "none";
        draw3D(points, index);
      } else if (viewMode === "2d-single") {
        plot3d.style.display = "none";
        plot2d.style.display = "block";
        grid.style.display = "none";
        selectProj.style.display = "inline-block";
        draw2DSingle(points, index, viewProj);
      } else {
        plot3d.style.display = "none";
        plot2d.style.display = "none";
        grid.style.display = "grid";
        selectProj.style.display = "none";
        draw2DGrid(points, index);
      }
    }

    function splitPareto(points) {
      const hasFlag = points.every(p => typeof p.isPareto === "boolean");
      const all = hasFlag ? points : findParetoFront(points);
      return {
        pareto: all.filter(p => p.isPareto),
        dom: all.filter(p => !p.isPareto)
      };
    }

    function axisRangesFor(proj) {
      const margin = 0.05;
      const xr = proj === "f2cov" ? [globalYMin, globalYMax] : [globalXMin, globalXMax]; // x=f2 en f2cov, si no x=f1
      const yr = (proj === "f1cov" || proj === "f2cov")
        ? [0, 100]  // cobertura en %
        : [globalYMin, globalYMax];

      const xSpan = xr[1] - xr[0];
      const ySpan = yr[1] - yr[0];
      return {
        x: [xr[0] - xSpan * margin, xr[1] + xSpan * margin],
        y: [yr[0] - ySpan * margin, yr[1] + ySpan * margin]
      };
    }

    function draw2DSingle(points, index, proj) {
      const { pareto, dom } = splitPareto(points);
      let xTitle = "", yTitle = "";
      let xPareto = [], yPareto = [], xDom = [], yDom = [];

      if (proj === "f1f2") {
        xTitle = "f1"; yTitle = "f2";
        xPareto = pareto.map(p => p.x); yPareto = pareto.map(p => p.y);
        xDom    = dom.map(p => p.x);    yDom    = dom.map(p => p.y);
      } else if (proj === "f1cov") {
        xTitle = "f1"; yTitle = "% Cobertura";
        xPareto = pareto.map(p => p.x); yPareto = pareto.map(p => p.coverage ?? null);
        xDom    = dom.map(p => p.x);    yDom    = dom.map(p => p.coverage ?? null);
      } else { // f2cov
        xTitle = "f2"; yTitle = "% Cobertura";
        xPareto = pareto.map(p => p.y); yPareto = pareto.map(p => p.coverage ?? null);
        xDom    = dom.map(p => p.y);    yDom    = dom.map(p => p.coverage ?? null);
      }

      // filtra nulos si hubiese puntos sin coverage
      const filterValid = (xs, ys) => {
        const xx = [], yy = [];
        for (let i = 0; i < xs.length; i++) if (ys[i] != null) { xx.push(xs[i]); yy.push(ys[i]); }
        return { x: xx, y: yy };
      };
      const p = filterValid(xPareto, yPareto);
      const d = filterValid(xDom, yDom);

      const ranges = axisRangesFor(proj);

      Plotly.react("plot2d", [
        {
          x: d.x, y: d.y, mode: "markers", name: "Dominados",
          marker: { size: 8, color: "blue" }
        },
        {
          x: p.x, y: p.y, mode: "markers", name: "Frente Pareto",
          marker: { size: 10, color: "red", symbol: "circle-open" }
        }
      ], {
        title: `Vista 2D (${proj}) - Gen ${index + 1}`,
        xaxis: { title: xTitle, range: ranges.x },
        yaxis: { title: yTitle, range: ranges.y },
        legend: { x: 1, y: 1, xanchor: "right", yanchor: "top",
                  bgcolor: "rgba(255,255,255,0.8)", bordercolor: "#ccc", borderwidth: 1 }
      });
    }

  function draw2DGrid(points, index) {
    draw2DSingle(points, index, "f1f2");
    // const l1 = document.getElementById("plot2d")._fullLayout; // para tomar estilos
    // f1 vs %cov
    const { pareto: p1, dom: d1 } = splitPareto(points);
    const r1 = axisRangesFor("f1cov");
    Plotly.react("plot2d-f1cov", [
      { x: d1.map(p => p.x), y: d1.map(p => p.coverage ?? null), mode: "markers", name: "Dominados",
        marker: { size: 8, color: "blue" } },
      { x: p1.map(p => p.x), y: p1.map(p => p.coverage ?? null), mode: "markers", name: "Frente Pareto",
        marker: { size: 10, color: "red", symbol: "circle-open" } }
    ], {
      title: `f1 vs % Cobertura - Gen ${index + 1}`,
      xaxis: { title: "f1", range: r1.x },
      yaxis: { title: "% Cobertura", range: r1.y },
      showlegend: false
    });

    // f2 vs %cov
    const r2 = axisRangesFor("f2cov");
    Plotly.react("plot2d-f2cov", [
      { x: d1.map(p => p.y), y: d1.map(p => p.coverage ?? null), mode: "markers", name: "Dominados",
        marker: { size: 8, color: "blue" } },
      { x: p1.map(p => p.y), y: p1.map(p => p.coverage ?? null), mode: "markers", name: "Frente Pareto",
        marker: { size: 10, color: "red", symbol: "circle-open" } }
    ], {
      title: `f2 vs % Cobertura - Gen ${index + 1}`,
      xaxis: { title: "f2", range: r2.x },
      yaxis: { title: "% Cobertura", range: r2.y },
      showlegend: false
    });

    // f1 vs f2 (usar el mismo de plot2d pero replicamos para la grilla)
    const { pareto, dom } = splitPareto(points);
    const r0 = axisRangesFor("f1f2");
    Plotly.react("plot2d-f1f2", [
      { x: dom.map(p => p.x), y: dom.map(p => p.y), mode: "markers", name: "Dominados",
        marker: { size: 8, color: "blue" } },
      { x: pareto.map(p => p.x), y: pareto.map(p => p.y), mode: "markers", name: "Frente Pareto",
        marker: { size: 10, color: "red", symbol: "circle-open" } }
    ], {
      title: `f1 vs f2 - Gen ${index + 1}`,
      xaxis: { title: "f1", range: r0.x },
      yaxis: { title: "f2", range: r0.y },
      showlegend: false
    });
  }

document.getElementById("btn-mode-3d").addEventListener("click", () => {
  viewMode = "3d";
  drawFinalViews(frames[parseInt(slider.value)], parseInt(slider.value));
});

document.getElementById("btn-mode-2d-single").addEventListener("click", () => {
  viewMode = "2d-single";
  drawFinalViews(frames[parseInt(slider.value)], parseInt(slider.value));
});

document.getElementById("btn-mode-2d-grid").addEventListener("click", () => {
  viewMode = "2d-grid";
  drawFinalViews(frames[parseInt(slider.value)], parseInt(slider.value));
});

document.getElementById("select-2d-proj").addEventListener("change", (e) => {
  viewProj = e.target.value;
  if (viewMode === "2d-single") {
    drawFinalViews(frames[parseInt(slider.value)], parseInt(slider.value));
  }
});


  </script>

</body>
</html>
