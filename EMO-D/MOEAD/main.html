<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MOEA/D – Visualizador</title>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <style>
    :root{
--bg:#f6f7fb; --panel:#ffffff; --text:#0f172a; --muted:#64748b; --border:#e2e8f0;
--accent:#2563eb; --ok:#16a34a; --warn:#f59e0b; --danger:#ef4444;
}

   
    *{box-sizing:border-box}
    html,body{
  font-size:16px;
}
    body{ font-size:20px; margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}

    /* Barra de pestañas */
    .tabs{
      position:sticky; top:0; z-index:10;
      display:flex; gap:.6rem; padding:.8rem 1rem;
      border-bottom:1px solid var(--border);
      background:var(--panel);
      box-shadow:0 1px 0 var(--border);
    }  
    /* Pestaña */
    .tab-btn{border:1px solid var(--border); background:var(--panel); color:var(--text); padding:.75rem 1.15rem; border-radius:.8rem; cursor:pointer; font-weight:700; font-size:1.05rem;}

    .tab-btn.active{background:#fff;color:var(--accent);border-color:var(--accent);box-shadow:0 0 0 2px rgba(37,99,235,.15) inset}


    /* Layout visualizador */
    .wrap{padding:1rem;display:grid;gap:1rem}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:1rem;padding:1rem}
    .row{display:flex;gap:.6rem;flex-wrap:wrap;align-items:center}
    label{
      font-size:1rem; color:#334155; font-weight:600;
    }
    /* Inputs negros */
    select, input[type="number"], input[type="text"], textarea{
      background:#fff; color:#0f172a;
      border:1px solid #cbd5e1; border-radius:.6rem;
      padding:.6rem .8rem;
    }
    select::placeholder, input::placeholder, textarea::placeholder{ color:#94a3b8; }

    select{min-width:220px}
    input[type="number"]{width:120px}
    .btn{border:1px solid var(--border); background:var(--panel); color:var(--text); padding:.65rem 1.1rem; border-radius:.8rem; cursor:pointer; font-size:1rem; font-weight:600;}
    .btn.primary{ background:#2563eb; border-color:#1d4ed8; color:#fff; }
    .hint{font-size:1.4rem;color:var(--muted)}

    #plot,#hv-plot,#history-plot{height:360px;background:#fff;border:1px dashed #273048;border-radius:.8rem}
    #plot{height:560px}

    #pareto-map-wrapper{display:flex;gap:1rem;align-items:flex-start}
    #plot-col{flex:1;min-width:360px}
    #map-col{width:38%;min-width:300px}
    #map{height:360px;background:#fff;border:1px dashed #273048;border-radius:.8rem}

    #stats-container{white-space:pre-wrap;text-align:left;font-family:monospace;margin:10px 0 0;display:none}
    #slider-container{margin-top:12px}

    /* Builder */
    #builder-canvas{width:100%;max-width:900px;border:1px dashed #999;background:#fff}
    #points-table{
        width:100%;
        border-collapse:collapse;
        font-size:1rem;
        line-height:1.35;
      }
    #points-table th,#points-table td{
        border:1px solid var(--border);
        padding:10px 12px;
        text-align:center;
      }

    #points-table input, #points-table select{ font-size:1rem; padding:.55rem .7rem; border-radius:.6rem; }
    #points-table button{ font-size:.95rem; padding:.4rem .65rem; border-radius:.5rem; }

    .pill{padding:4px 8px;border-radius:999px;border:1px solid #444}

    /* Secciones */
    .section{display:none}
    .section.active{display:block}

    @media (max-width:1100px){#pareto-map-wrapper{flex-direction:column} #map-col{width:100%}}
    .section-title{font-size:1.5rem;font-weight:700;color:var(--text);margin:.2rem 0 1rem}

    /* Barra de controles (Instancia, Semilla, N° variables, Ejecutar, Cargar generaciones) */
    .wrap > .card:first-child .row label,
    .wrap > .card:first-child .row select,
    .wrap > .card:first-child .row input,
    .wrap > .card:first-child .row .btn,
    .wrap > .card:first-child .row .hint{
      font-size: 1.5rem;   /* ← súbelo, por ejemplo a 1.15rem o 1.2rem */
    }

    .all-grid{ display:grid; grid-template-columns:repeat(2, minmax(0, 1fr)); gap:1rem; }
    @media (max-width: 1200px){
      .all-grid{ grid-template-columns: 1fr; }
    }
    .all-card{ background:var(--panel); border:1px solid var(--border); border-radius:1rem; padding:1rem; }
    .all-card h4{ margin:0 0 .5rem 0; }
    .all-row{ display:grid; grid-template-columns: 1fr 0.85fr; gap:1rem; }
    .all-plot{ height:520px; background:#fff; border:1px dashed var(--border); border-radius:.8rem; }
    .all-small{ height:340px; background:#fff; border:1px dashed var(--border); border-radius:.8rem; }
    .all-slider{ margin-top:.5rem; }
    /* Fix solapamientos en pestaña “Todo” */
    .all-card{ overflow: hidden; }
    .all-row{ align-items: start; }
    .all-plot, .all-small{ width:100%; min-width:0; display:block; }
    @media (max-width:1100px){ .all-row{ grid-template-columns:1fr; } }

    .hidden {display: none;}
    .map-card {width: 50%; max-width: 1200px;}
    #map-image {width: 100%; height: auto; display: block;}

    #map-plot-container, #map-plot {
    height: 100%;
    width: 100%;
}

  </style>
</head>
<body>
  <!-- PESTAÑAS -->
  <div class="tabs">
    <button id="btn-tab-visualizador" class="tab-btn active">Visualizador</button>
    <button id="btn-tab-builder" class="tab-btn">Crear instancia</button>
    <button id="btn-tab-all" class="tab-btn">Ver todas las instancia</button>
  </div>

  <!-- SECCIÓN: VISUALIZADOR -->
  <section id="tab-visualizador" class="section active">
    <div class="wrap">
      <div class="card">
        <div class="row">
          <div class="field">
            <label for="instancia">Instancia</label>
            <select id="instancia" name="instancia"></select>
          </div>
          <div class="field">
            <label for="semilla">Semilla</label>
            <input id="semilla" type="number" value="1" min="0" step="1" />
          </div>
          <div class="field">
            <label for="num_var">N° variables</label>
            <input id="num_var" type="number" value="100" min="1" step="1" />
          </div>
          <button class="btn primary" id="btn-ejecutar">Ejecutar</button>
          <button class="btn" id="load-btn">Cargar generaciones</button>
          <label class="hint"><input type="checkbox" id="fix-scale" checked/> Usar misma escala</label>
          <label class="hint"><input type="checkbox" id="recalcular-hv"/> Recalcular HV</label>
          <label class="hint"><input type="checkbox" id="toggle-prob" checked /> Probabilidad en mapa</label>
          <span id="status" class="hint">Listo</span>
        </div>
      </div>

      <div class="card" id="pareto-map-wrapper">
        <div id="plot-col">
          <div id="plot"></div>
          <div id="stats-container"></div>
          <div id="slider-container" style="display:none">
            <input type="range" id="slider" min="0" max="0" value="0" style="width:100%" />
            <p class="hint">Generación: <span id="gen-num">1</span></p>
          </div>
        </div>
        <!-- <div id="map-col">
          <h3 class="hint">Configuración seleccionada</h3>
          <img id="map-image" src="" alt="Mapa" style="width:100%;border:1px solid #333;border-radius:.6rem" />
        </div> -->
        <div class="map-card">
          <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
          <button id="btn-toggle-map" type="button" class="btn hidden">Ver mapa interactivo</button>
        </div>

        <div id="map-image-container" class="hidden">
          <img id="map-image" src="" alt="Mapa AEDs">
        </div>

        <div id="map-plot-container" class="hidden">
          <div id="map-plot" style="width: 100%; height: 640px;"></div>
        </div>

        <pre id="map-stats" style="white-space: pre-wrap; margin-top: 8px;"></pre>
        </div>
      </div>

      <div class="card"><h3 class="section-title">Hipervolumen</h3><div id="hv-plot"></div></div>
      <div class="card"><h3 class="section-title">Historial de frentes</h3><div id="history-plot"></div></div>
    </div>
  </section>

  <!-- SECCIÓN: CONSTRUCTOR -->
  <section id="tab-builder" class="section">
    <div class="wrap">
      <div class="card" id="instance-builder">
        <h2>Constructor de instancias</h2>
        <div class="row">
          <div>
            <label>Nombre de instancia (.dat)</label>
            <input type="text" id="ib-name" placeholder="Ej: Escuela_A.dat" style="min-width:260px" />
          </div>
          <div><label class="pill">Modo:
            <select id="ib-mode"><option value="0">Marcar demanda (OHCA)</option><option value="1">Marcar AED preinstalado</option></select>
          </label></div>
          <div><label class="pill">Prob. por defecto (0.1–1.0)
            <input type="number" id="ib-prob" step="0.01" min="0.1" max="1.0" value="1.0" style="width:90px" />
          </label></div>
          <div><label class="pill">Cuadrícula(px)
            <input type="number" id="ib-grid" step="5" min="10" value="50" style="width:90px" />
          </label>
            <label class="pill"><input type="checkbox" id="ib-grid-on" /> Mostrar cuadrícula</label>
          </div>
        </div>

        <div class="row" style="margin-top:8px">
          <input type="file" id="ib-file" accept="image/png,image/jpeg,image/webp" />
          <button class="btn" id="ib-upload">Subir imagen</button>
          <span class="hint">Sugerencia: imagen/plano para referenciar coordenadas.</span>
        </div>

        <div style="margin-top:10px"><canvas id="builder-canvas" width="900" height="600"></canvas></div>

        <div class="row" style="margin-top:8px">
          <label class="pill">Presupuesto (P)
            <input id="ib-P" type="number" step="1" min="0" value="100000" style="width:110px" />
          </label>
          <label class="pill">Radio (R)
            <input id="ib-R" type="number" step="1" min="1" value="800" style="width:110px" />
          </label>
          <label class="pill">Costo instalación (c1)
            <input id="ib-c1" type="number" step="0.01" min="0" value="1.0" style="width:110px" />
          </label>
          <label class="pill">Costo reubicación (c2)
            <input id="ib-c2" type="number" step="0.01" min="0" value="1.0" style="width:110px" />
          </label>
        </div>

        <div class="row" style="margin-top:10px">
          <button class="btn" id="ib-undo">Deshacer último punto</button>
          <button class="btn" id="ib-clear">Limpiar todo</button>
          <button class="btn" id="ib-save">Guardar instancia</button>
        </div>

        <details style="margin-top:12px"><summary>Ver puntos</summary>
          <table id="points-table"><thead><tr><th>ID</th><th>X</th><th>Y</th><th>Flag</th><th>Prob</th><th>Acciones</th></tr></thead><tbody id="points-tbody"></tbody></table>
        </details>
      </div>
    </div>
  </section>

  <!-- SECCIÓN: Todas las instancias -->
<section id="tab-all" class="section">
  <div class="wrap">
    <div class="card">
      <div class="row">
        <label class="hint"><input type="checkbox" id="toggle-prob-all" checked /> Probabilidad en mapa</label>
        <label class="hint"><input type="checkbox" id="fix-scale-all" checked /> Misma escala</label>
        <span id="status-all" class="hint">Sin cargar</span>
      </div>
    </div>
    <div id="all-grid" class="all-grid"></div>
  </div>
</section>



  <script>
    
    // ===== Helpers =====
    const $ = (s, r=document) => r.querySelector(s);
    const $$ = (s, r=document) => Array.from(r.querySelectorAll(s));
    const PLOTLY_CFG = { responsive: true, displayModeBar: false };

    let currentMapJsonData = null;

    
    // === Tooltips compactos + panel de detalle ===
    function compressRanges(ids, maxTokens = 10) {
      if (!Array.isArray(ids) || !ids.length) return [];
      const arr = [...new Set(ids)].sort((a,b)=>a-b);
      const out = [];
      let s = arr[0], p = arr[0];
      const push = (a,b)=> out.push(a===b ? `${a}` : `${a}–${b}`);
      for (let i=1;i<arr.length;i++){
        const v = arr[i];
        if (v === p + 1) { p = v; continue; }
        push(s,p); s = p = v;
      }
      push(s,p);
      if (out.length > maxTokens) {
        const head = out.slice(0, maxTokens).join(', ');
        return [head + ` … (+${out.length - maxTokens} más)`];
      }
      return out;
    }

    // texto de hover resumido: coord + conteo + ids comprimidos
    function mkHoverTextPt(p, maxTokens=8){
      const ids = p.ids || [];
      const ranges = compressRanges(ids, maxTokens).join(', ');
      return `(${Number(p.x).toFixed(2)}, ${Number(p.y).toFixed(2)})<br>` +
            `IDs (${ids.length}): ${ranges}`;
    }

    // crea (si no existe) un panel debajo del gráfico para ver/copy el detalle
    function ensureDetailPanelAfter(plotElOrId, suffix='main'){
      const plotEl = typeof plotElOrId === 'string' ? document.getElementById(plotElOrId) : plotElOrId;
      let panel = document.getElementById('ids-panel-' + suffix);
      if (!panel) {
        panel = document.createElement('div');
        panel.id = 'ids-panel-' + suffix;
        panel.style.marginTop = '8px';
        panel.style.padding = '8px';
        panel.style.border = '1px solid #e3e3e3';
        panel.style.borderRadius = '8px';
        panel.style.maxHeight = '140px';
        panel.style.overflow = 'auto';
        panel.style.fontSize = '12px';
        plotEl.parentNode.insertBefore(panel, plotEl.nextSibling);
      }
      return panel;
    }


    // ===== Tabs =====
    const tabVisBtn = $('#btn-tab-visualizador');
    const tabBldBtn = $('#btn-tab-builder');
    const tabAllBtn = $('#btn-tab-all');
    const tabVis = $('#tab-visualizador');
    const tabBld = $('#tab-builder');
    const tabAll = $('#tab-all');
    function showTab(which){
      const vis = which === 'visualizador';
      const bld = which === 'builder';
      const all = which === 'all';

      tabVis.classList.toggle('active', vis); tabVisBtn.classList.toggle('active', vis);
      tabBld.classList.toggle('active', bld); tabBldBtn.classList.toggle('active', bld);
      tabAll.classList.toggle('active', all); tabAllBtn.classList.toggle('active', all);
      window.scrollTo({top:0, behavior:'smooth'});
      if (all) buildAllDashboard();      
    }
    tabVisBtn.addEventListener('click', ()=>showTab('visualizador'));
    tabBldBtn.addEventListener('click', ()=>showTab('builder'));
    tabAllBtn.addEventListener('click', ()=>showTab('all'));

    // ===== Visualizador Elements =====
    const toggleProb = $('#toggle-prob');
    let lastIds = null;
    let lastInstancia = null;
    const selInst = $('#instancia');
    const inputSeed = $('#semilla');
    const inputVars = $('#num_var');
    const statusEl = $('#status');
    const fixScaleCheckbox = $('#fix-scale');

    const plotDiv = $('#plot');
    const sliderContainer = $('#slider-container');
    const slider = $('#slider');
    const genNum = $('#gen-num');

    // ==== Pestaña TODO ====
    const framesAll = {};    // inst -> [ [points], ... ]
    let lastIdsAll = null, lastInstAll = null;
    let prefetchDone = false;

    const selProbAll = $('#toggle-prob-all');
    const statusAll  = $('#status-all');
    const gridAll    = $('#all-grid');

    const allCache = {};           // inst -> { files, hv }
    const framesPerInst = {};      // inst -> [ [points]... ]
    const lastSelPerInst = {};     // inst -> ids[]
    let allBuilt = false;

    const slug = s => s.replace(/[^a-zA-Z0-9_-]/g,'_');

    const fixScaleAll = document.getElementById('fix-scale-all');
    const rangesPerInst = {};       // inst -> { x:[min,max], y:[min,max] }
    const currentGenIndex = {};     // inst -> índice actual del slider



    // ===== Data holders =====
    let frames = []; let hvValues = [];
    let globalXMin = Infinity, globalXMax = -Infinity, globalYMin = Infinity, globalYMax = -Infinity;
    let globalCovMin = Infinity, globalCovMax = -Infinity;

    // ===== Instancias =====
    async function refreshInstanciaSelect(){
      try{
        const r = await fetch('/list_instances');
        const j = await r.json();
        const arr = Array.isArray(j) ? j : (j.instances || []);
        selInst.innerHTML = arr.map(fn=>`<option value="${fn}">${fn}</option>`).join('');
      }catch(e){ console.warn('No se pudo listar instancias', e); }
    }

    async function fetchNFromInstance(filename){
      try{
        const res = await fetch('/get/' + 'INSTANCES/' + filename);
        if(!res.ok) return null; const txt = await res.text();
        const m1 = txt.match(/set\s+N\s*:=\s*(\d+)\s*;/i); if(m1) return parseInt(m1[1],10);
        const start = txt.search(/param\s*:\s*coordx\s+coordy\s+flag\s+prob_ohca\s*:=/i);
        if(start>=0){
          const rest = txt.slice(start); const end = rest.search(/;\s*$/m);
          const block = end>=0? rest.slice(0,end): rest;
          const lines = block.split('\n').map(s=>s.trim()).filter(s=>/^\d+(\s|$)/.test(s));
          if(lines.length>0) return lines.length;
        }
      }catch(e){ console.warn('No se pudo leer N de la instancia:', e); }
      return null;
    }
    function setNumVarTo(N){
      let opt = Array.from(inputVars.options||[]).find(o=>parseInt(o.value,10)===N);
      if(!opt){ opt = document.createElement('option'); opt.value=String(N); opt.textContent=String(N); inputVars.appendChild(opt); }
      inputVars.value = String(N);
    }
    async function syncVariablesFromInstance(filename){ const N = await fetchNFromInstance(filename); if(N) setNumVarTo(N); }

    // ===== Visualizador: Correr / Cargar =====
    async function runNow(){
      const payload = { instancia: selInst.value, semilla: Number(inputSeed.value||0), num_var: Number(inputVars.value||0) };
      statusEl.textContent = 'Ejecutando…';
      const res = await fetch('/run', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
      if(!res.ok){ statusEl.textContent='Error en ejecución'; return; }
      const data = await res.json();
      if(!data.files || !data.files.length){ statusEl.textContent='⚠️ No se generaron archivos.'; return; }
      await loadGenerations(data.files, data.hv||[]);
      statusEl.textContent = `Listo: ${frames.length} generaciones`;
    }

    async function loadSaved(){
      statusEl.textContent = 'Cargando generaciones…';
      const payload = { instancia: selInst.value, semilla: Number(inputSeed.value||0), recalcular: $('#recalcular-hv').checked };
      const res = await fetch('/load', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
      const data = await res.json();
      if(!data.files || !data.files.length){ statusEl.textContent='⚠️ No se encontraron generaciones.'; return; }
      await loadGenerations(data.files, data.hv||[]);
      statusEl.textContent = `Listo: ${frames.length} generaciones`;
    }

    // ===== Visualizador: Plot logic =====
    function findParetoFront(points){
      if(!points||!Array.isArray(points)||!points.length) return [];
      const isDom = new Array(points.length).fill(false);
      for(let i=0;i<points.length;i++) for(let j=0;j<points.length;j++) if(i!==j){
        if(points[j].x<=points[i].x && points[j].y<=points[i].y && (points[j].x<points[i].x || points[j].y<points[i].y)) { isDom[i]=true; break; }
      }
      return points.map((p,i)=>({...p,isPareto:!isDom[i]}));
    }
    function getMultiColor(f){ const cs=["#440154","#3b528b","#21918c","#fde725","#ff7f00"]; const s=f*(cs.length-1); const i1=Math.floor(s); const i2=Math.min(i1+1,cs.length-1); const t=s-i1; const c1=cs[i1].slice(1), c2=cs[i2].slice(1); const r1=parseInt(c1.slice(0,2),16),g1=parseInt(c1.slice(2,4),16),b1=parseInt(c1.slice(4),16); const r2=parseInt(c2.slice(0,2),16),g2=parseInt(c2.slice(2,4),16),b2=parseInt(c2.slice(4),16); const r=Math.round(r1+t*(r2-r1)),g=Math.round(g1+t*(g2-g1)),b=Math.round(b1+t*(b2-b1)); return `rgb(${r},${g},${b})`; }

    async function loadGenerations(files, hvs){
      frames=[]; hvValues=hvs; globalXMin=Infinity; globalXMax=-Infinity; globalYMin=Infinity; globalYMax=-Infinity; globalCovMin=Infinity; globalCovMax=-Infinity;
      for(const file of files){ const res = await fetch('/get/'+file); const text = await res.text();
        const puntos = text.trim().split('\n').map(l=>l.trim()).filter(l=>l && !l.startsWith('#')).map(line=>{
          let coverage=null; let left=line; if(line.includes('|')){ const parts=line.split('|'); left=parts[0].trim(); const covStr=parts[1].trim().split(/\s+/)[0]; const covVal=parseFloat(covStr); if(!Number.isNaN(covVal)) coverage=covVal; }
          const toks = left.split(/\s+/); const f1=parseFloat(toks[0]); const f2=parseFloat(toks[1]); let startIdx=2; let isPareto;
          if(Number.isNaN(parseFloat(toks[2]))){ if(toks[2]==='P'){isPareto=true; startIdx=3;} else if(toks[2]==='D'){isPareto=false; startIdx=3;} else if(toks[2]==='-' && line.includes('IDs instalados:')){ const right=line.split('IDs instalados:')[1]||''; const ids=right.trim().split(/\s+/).map(Number).filter(n=>!Number.isNaN(n)); updateRanges(f1,f2); return {x:f1,y:f2,ids,isPareto,coverage}; } }
          const ids = toks.slice(startIdx).map(n=>parseInt(n,10)).filter(n=>!Number.isNaN(n)); updateRanges(f1,f2); if(typeof coverage==='number'&&!Number.isNaN(coverage)){ if(coverage<globalCovMin) globalCovMin=coverage; if(coverage>globalCovMax) globalCovMax=coverage; }
          return {x:f1,y:f2,ids,isPareto,coverage}; });
        frames.push(puntos);
      }
      showGeneration(0); sliderContainer.style.display='block'; slider.max=frames.length-1; slider.value=0; genNum.innerText=1;
      // HV
      Plotly.newPlot('hv-plot',[{x:hvValues.map((_,i)=>i+1), y:hvValues, mode:'lines+markers', marker:{color:'green'}, line:{color:'green'}, name:'Hipervolumen'}], {title:'Evolución del Hipervolumen', xaxis:{title:'Generación'}, yaxis:{title:'Hipervolumen'}, paper_bgcolor:'#fff', plot_bgcolor:'#fff'});
      document.getElementById('hv-plot').on('plotly_click', d=>{ const gen=d.points[0].x; slider.value=gen-1; genNum.innerText=gen; showGeneration(gen-1); });
      // Historial
      const traces = frames.map((pts,idx)=>{ const hasFlag=pts.every(p=>typeof p.isPareto==='boolean'); const all=hasFlag?pts:findParetoFront(pts); const pareto=all.filter(p=>p.isPareto); const color=getMultiColor(idx/Math.max(1,(frames.length-1))); return {x:pareto.map(p=>p.x), y:pareto.map(p=>p.y), mode:'markers', marker:{size:6, color}, name:`Gen ${idx+1}`, showlegend:false}; });
      Plotly.newPlot('history-plot', traces, {title:'Historial de Frentes de Pareto', xaxis:{title:'f1'}, yaxis:{title:'f2'}});
      function updateRanges(f1,f2){ if(f1<globalXMin)globalXMin=f1; if(f1>globalXMax)globalXMax=f1; if(f2<globalYMin)globalYMin=f2; if(f2>globalYMax)globalYMax=f2; }
    }

    function showGeneration(index){
      const points = frames[index]; if(!points||!Array.isArray(points)) return;
      const hasFlag = points.every(p=>typeof p.isPareto==='boolean');
      const allPoints = hasFlag? points : findParetoFront(points);
      const paretoPoints = allPoints.filter(p=>p.isPareto);
      const dominatedPoints = allPoints.filter(p=>!p.isPareto);

      const layout = {
        title:`Frente de Pareto - Gen ${index+1}`,
        xaxis:{title:'Minimizar Cobertura (f1)'},
        yaxis:{title:'Minimizar Costos (f2)'},
        legend:{x:1,y:1,xanchor:'right',yanchor:'top',bgcolor:'rgba(255,255,255,.08)',bordercolor:'#333',borderwidth:1},
        hovermode: 'closest'
      };
      if (fixScaleCheckbox.checked){
        const xM=(globalXMax-globalXMin)*0.05, yM=(globalYMax-globalYMin)*0.05;
        layout.xaxis.range=[globalXMin-xM,globalXMax+xM];
        layout.yaxis.range=[globalYMin-yM,globalYMax+yM];
      }

      // texto de hover resumido
      const domText    = dominatedPoints.map(p=>mkHoverTextPt(p));
      const paretoText = paretoPoints.map(p=>mkHoverTextPt(p));

      Plotly.react(plotDiv, [
        {
          x: dominatedPoints.map(p=>p.x),
          y: dominatedPoints.map(p=>p.y),
          customdata: dominatedPoints.map(p=>p.ids),
          text: domText,
          mode:'markers',
          marker:{size:8, color:'blue'},
          name:'Dominados',
          hovertemplate: '%{text}<extra></extra>',
          hoverlabel: { align:'left', namelength: 0 }
        },
        {
          x: paretoPoints.map(p=>p.x),
          y: paretoPoints.map(p=>p.y),
          customdata: paretoPoints.map(p=>p.ids),
          text: paretoText,
          mode:'markers',
          marker:{size:10, color:'red', symbol:'circle-open'},
          name:'Frente Pareto',
          hovertemplate: '%{text}<extra></extra>',
          hoverlabel: { align:'left', namelength: 0 }
        }
      ], layout);

      // click: mapa + panel de detalle con todos los IDs (copiable)
      plotDiv.removeAllListeners?.('plotly_click');
      plotDiv.on('plotly_click', async d => {
          const point = d.points[0];
          const idsSel = point.customdata || [];
          const instanciaActual = selInst.value;

          lastIds = idsSel;
          lastInstancia = instanciaActual;

          const payload = {
              instancia: instanciaActual,
              ids: idsSel,
              show_probs: toggleProb.checked,
              x: point.x,
              y: point.y
          };

          // 1. Esconder todo y mostrar mensaje de carga
          $('#map-image-container').classList.add('hidden');
          $('#map-plot-container').classList.add('hidden');
          $('#map-stats').textContent = 'Cargando mapas...';
          
          // 2. Ejecutar AMBAS peticiones de mapa en paralelo
          const peticionEstatica = fetch('/map', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
          });
          const peticionInteractiva = fetch('/map_json', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
          });

          try {
              // 3. Esperar a que ambas terminen
              const [resStatic, resJson] = await Promise.all([peticionEstatica, peticionInteractiva]);

              if (!resStatic.ok || !resJson.ok) {
                  throw new Error('Una o ambas peticiones de mapa fallaron');
              }

              const staticData = await resStatic.json();
              const jsonData = await resJson.json();

              // 4. Guardar datos y renderizar
              currentMapJsonData = jsonData;
              renderInteractiveMap('map-plot', currentMapJsonData); // Renderiza el interactivo (aún oculto)
              
              // 5. Cargar la imagen estática y las estadísticas
              $('#map-image').src = 'data:image/png;base64,' + staticData.img;
              $('#map-stats').textContent = jsonData.stats || staticData.stats;

              // 6. Mostrar la VISTA POR DEFECTO (estática) y el botón
              $('#map-image-container').classList.remove('hidden');
              $('#btn-toggle-map').classList.remove('hidden');
              $('#btn-toggle-map').textContent = 'Ver mapa interactivo';

          } catch (e) {
              console.error(e);
              $('#map-stats').textContent = '❌ No se pudo generar el mapa.';
          }
      });
    
    }


    toggleProb.addEventListener('change', async () => {
    // Si no hay datos de mapa cargados, no hace nada
    if (!currentMapJsonData || !lastIds || !lastInstancia) return;

    // Actualiza la variable global con el nuevo estado del checkbox
    currentMapJsonData.meta.show_probs = toggleProb.checked;

    // Vuelve a pedir los datos JSON con la nueva configuración
    const payload = {
        instancia: lastInstancia,
        ids: lastIds,
        show_probs: toggleProb.checked,
    };

    $('#map-stats').textContent = 'Refrescando mapas...';

    const peticionEstatica = fetch('/map', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    });

    const peticionInteractiva = fetch('/map_json', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    });

    try {
        const [resStatic, resJson] = await Promise.all([peticionEstatica, peticionInteractiva]);

        if (!resJson.ok) throw new Error('Fallo al refrescar datos JSON del mapa');
        const staticData = await resStatic.json();
        const jsonData= await resJson.json(); // Actualizar datos


        $('#map-image').src = 'data:image/png;base64,' + staticData.img;
        currentMapJsonData = jsonData; // Actualiza la variable global con los nuevos datos
        // Vuelve a dibujar el mapa interactivo con los datos actualizados
        renderInteractiveMap('map-plot', currentMapJsonData);
        
        // Actualiza también las estadísticas
        $('#map-stats').textContent = jsonData.stats|| staticData.stats;
        

    } catch (e) {
        console.error("Error al refrescar el mapa interactivo:", e);
        $('#map-stats').textContent = '❌ Error al refrescar mapa.';
    }
});

    slider.addEventListener('input',()=>{ const i=parseInt(slider.value,10); genNum.innerText=i+1; showGeneration(i); });
    $('#btn-ejecutar').addEventListener('click', runNow);
    $('#load-btn').addEventListener('click', loadSaved);
    fixScaleCheckbox.addEventListener('change', ()=>showGeneration(parseInt(slider.value||'0',10)));

    // ====== Builder logic ======
    const ib = { name:$('#ib-name'), mode:$('#ib-mode'), prob:$('#ib-prob'), grid:$('#ib-grid'), gridOn:$('#ib-grid-on'), file:$('#ib-file'), uploadBtn:$('#ib-upload'), canvas:$('#builder-canvas'), ctx:null, img:new Image(), points:[], nextId:1 };
    ib.ctx = ib.canvas.getContext('2d');

    function drawBuilder(){ const ctx=ib.ctx; ctx.clearRect(0,0,ib.canvas.width,ib.canvas.height); if(ib.img && ib.img.complete){ ctx.drawImage(ib.img,0,0,ib.canvas.width,ib.canvas.height); } if(ib.gridOn.checked){ const step=Math.max(10, parseInt(ib.grid.value||'50',10)); ctx.save(); ctx.strokeStyle='#233'; for(let x=0;x<ib.canvas.width;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,ib.canvas.height); ctx.stroke(); } for(let y=0;y<ib.canvas.height;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(ib.canvas.width,y); ctx.stroke(); } ctx.restore(); } for(const p of ib.points){ const color = p.flag===1? '#e53935':'#1e88e5'; ctx.fillStyle=color; ctx.strokeStyle='#000'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(p.x,p.y,8,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle='#fff'; ctx.font='14px monospace'; ctx.fillText(String(p.id), p.x+10, p.y-10); } }

    ib.canvas.addEventListener('click', ev=>{ const r=ib.canvas.getBoundingClientRect(); const x=ev.clientX-r.left; const y=ev.clientY-r.top; const flag=parseInt(ib.mode.value,10); let prob=parseFloat(ib.prob.value); if(isNaN(prob)||prob<=0) prob=1.0; ib.points.push({id:ib.nextId++, x:Math.round(x), y:Math.round(y), flag, prob:+prob.toFixed(2)}); drawBuilder(); renderPointsTable(); });

    function renderPointsTable(){ const tb=$('#points-tbody'); tb.innerHTML=''; for(const p of ib.points){ const tr=document.createElement('tr'); tr.innerHTML=`<td>${p.id}</td><td><input type="number" value="${p.x}" style="width:110px" data-id="${p.id}" data-k="x"></td><td><input type="number" value="${p.y}" style="width:80px" data-id="${p.id}" data-k="y"></td><td><select data-id="${p.id}" data-k="flag" style="width:90px"><option value="0" ${p.flag===0?'selected':''}>0</option><option value="1" ${p.flag===1?'selected':''}>1</option></select></td><td><input type="number" step="0.01" min="0.1" max="1.0" value="${p.prob}" style="width:110px" data-id="${p.id}" data-k="prob"></td><td><button data-id="${p.id}" data-act="del">Eliminar</button></td>`; tb.appendChild(tr); }
      tb.querySelectorAll('input,select,button').forEach(el=>{ if(el.tagName==='BUTTON'){ el.addEventListener('click',()=>{ const id=+el.getAttribute('data-id'); ib.points = ib.points.filter(p=>p.id!==id); drawBuilder(); renderPointsTable(); }); } else { el.addEventListener('change',()=>{ const id=+el.getAttribute('data-id'); const k=el.getAttribute('data-k'); const p=ib.points.find(r=>r.id===id); if(!p) return; let v=el.value; if(k==='x'||k==='y') v=Math.round(parseFloat(v)); if(k==='flag') v=parseInt(v,10); if(k==='prob') v=Math.min(1.0, Math.max(0.1, parseFloat(v))); p[k]=v; drawBuilder(); }); } }); }

    ib.uploadBtn.addEventListener('click', async()=>{ if(!ib.file.files[0]){ alert('Selecciona una imagen'); return; } const fd=new FormData(); fd.append('image', ib.file.files[0]); fd.append('name', ib.name.value.replace('.dat','')||'map'); const res=await fetch('/upload_map',{method:'POST', body:fd}); if(!res.ok){ alert('No se pudo subir la imagen'); return; } const json=await res.json(); const url=json.url; ib.img=new Image(); ib.img.onload=()=>drawBuilder(); ib.img.src=url; });
    $('#ib-grid-on').addEventListener('change', drawBuilder); $('#ib-grid').addEventListener('change', drawBuilder);
    $('#ib-undo').addEventListener('click', ()=>{ ib.points.pop(); drawBuilder(); renderPointsTable(); });
    $('#ib-clear').addEventListener('click', ()=>{ ib.points=[]; ib.nextId=1; drawBuilder(); renderPointsTable(); });

    $('#ib-save').addEventListener('click', async()=>{
      const name=(ib.name.value||'').trim(); if(!name){ alert('Ponle un nombre a la instancia'); return; }
      if(ib.points.length===0){ alert('Agrega al menos un punto'); return; }
      const h=ib.canvas.height; const payload={ name: name.endsWith('.dat')? name : (name+'.dat'), points: ib.points.map(p=>({id:p.id,x:p.x,y:h-p.y,flag:p.flag,prob:p.prob})), presupuesto:Number($('#ib-P').value||0), radio:Number($('#ib-R').value||800), c1:Number($('#ib-c1').value||1.0), c2:Number($('#ib-c2').value||1.0) };
      const res=await fetch('/save_instance',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)}); const j=await res.json(); if(!res.ok){ alert('Error guardando: '+(j.error||'desconocido')); return; }
      // Actualizar selector, seleccionar nueva y volver al visualizador
      await refreshInstanciaSelect(); const fname = payload.name; selInst.value = fname; try{ await syncVariablesFromInstance(fname); }catch(_){ }
      statusEl.textContent = 'Instancia creada. Ahora puedes ejecutarla';
      showTab('visualizador');
      window.scrollTo({top:0, behavior:'smooth'});
    });

    // ===== Inicio =====
    window.addEventListener('DOMContentLoaded', async()=>{ await refreshInstanciaSelect(); showTab('visualizador'); statusEl.textContent='Listo'; drawBuilder(); });

    async function buildAllDashboard(){
      if (allBuilt) return;
      statusAll.textContent = 'Cargando…';

      const r = await fetch('/list_instances');
      const j = await r.json();
      const insts = Array.isArray(j) ? j : (j.instances || []);

      const withData = [];
      for (const inst of insts) {
        const res = await fetch('/load', {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ instancia: inst, semilla: 0, recalcular: false })
        });
        if (!res.ok) continue;
        const data = await res.json();
        if (data.files && data.files.length) {
          allCache[inst] = data;
          withData.push(inst);
        }
      }

      for (const inst of withData) {
        const id = slug(inst);
        gridAll.insertAdjacentHTML('beforeend', `
          <div class="all-card" id="card-${id}">
            <h4>${inst}</h4>
            <div class="all-row">
              <div>
                <div id="plot-${id}" class="all-plot"></div>
                <div class="all-slider">
                  <input type="range" id="slider-${id}" min="0" max="0" value="0" style="width:100%" />
                  <p class="hint">Generación: <span id="gen-${id}">1</span></p>
                </div>
              </div>
              <div>
                <div id="hv-${id}" class="all-small"></div>
                <div id="hist-${id}" class="all-small" style="margin-top:1rem"></div>
                <img id="map-${id}" alt="Mapa" style="display:none;width:100%;border:1px solid #333;border-radius:.6rem;margin-top:1rem" />
                <div id="stats-${id}" style="white-space:pre-wrap;font-family:monospace;display:none;margin-top:.5rem"></div>
              </div>
            </div>
          </div>`);

        await renderInstanceCard(inst, id, allCache[inst]);
      }

      statusAll.textContent = `Cargadas: ${withData.length}`;
      allBuilt = true;
    }

    function parsePoints(text){
      return text.trim().split('\n')
        .map(l=>l.trim()).filter(l=>l && !l.startsWith('#'))
        .map(line=>{
          let coverage=null; let left=line;
          if(line.includes('|')){
            const parts=line.split('|');
            left=parts[0].trim();
            const covStr=parts[1].trim().split(/\s+/)[0];
            const covVal=parseFloat(covStr);
            if(!Number.isNaN(covVal)) coverage=covVal;
          }
          const toks = left.split(/\s+/);
          const f1=parseFloat(toks[0]); const f2=parseFloat(toks[1]);
          let startIdx=2; let isPareto;
          if(Number.isNaN(parseFloat(toks[2]))){
            if(toks[2]==='P'){ isPareto=true; startIdx=3; }
            else if(toks[2]==='D'){ isPareto=false; startIdx=3; }
          }
          const ids = toks.slice(startIdx).map(n=>parseInt(n,10)).filter(n=>!Number.isNaN(n));
          return { x:f1, y:f2, ids, isPareto, coverage };
        });
    }

    async function renderInstanceCard(inst, id, data){
      const files = data.files, hv = data.hv || [];
      const frames = [];
      for (const file of files) {
        const res = await fetch('/get/'+file);
        const text = await res.text();
        frames.push(parsePoints(text));
      }
      framesPerInst[inst] = frames;

      // Rango global para “Misma escala”
      let xMin=Infinity, xMax=-Infinity, yMin=Infinity, yMax=-Infinity;
      for (const gen of frames) {
        for (const p of gen) {
          if (p.x < xMin) xMin = p.x;
          if (p.x > xMax) xMax = p.x;
          if (p.y < yMin) yMin = p.y;
          if (p.y > yMax) yMax = p.y;
        }
      }
      rangesPerInst[inst] = { x:[xMin, xMax], y:[yMin, yMax] };
      currentGenIndex[inst] = 0;  // primera generación

      await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
      // HV
      Plotly.newPlot('hv-'+id,
        [{ x: hv.map((_,i)=>i+1), y: hv, mode:'lines+markers', name:'HV' }],
        { title:'Hipervolumen', xaxis:{title:'Generación'}, yaxis:{title:'HV'},
          paper_bgcolor:'#fff', plot_bgcolor:'#fff' }, PLOTLY_CFG
      ).then(gd=>{
        gd.on('plotly_click', d=>{
          const gen = d.points[0].x;
          const slider = $('#slider-'+id), genLbl = $('#gen-'+id);
          slider.value = gen-1; genLbl.textContent = gen;
          showGenInCard(inst, id, gen-1);
        });
      });

      // Historial
      const traces = frames.map((pts,idx)=>{
        const hasFlag = pts.every(p=>typeof p.isPareto==='boolean');
        const all = hasFlag ? pts : findParetoFront(pts);
        const pareto = all.filter(p=>p.isPareto);
        const color = getMultiColor(idx/Math.max(1,(frames.length-1)));
        return { x:pareto.map(p=>p.x), y:pareto.map(p=>p.y), mode:'markers',
                marker:{size:6, color}, showlegend:false };
      });
      Plotly.newPlot('hist-'+id, traces,
        { title:'Frentes', xaxis:{title:'f1'}, yaxis:{title:'f2'},
          paper_bgcolor:'#fff', plot_bgcolor:'#fff' }, PLOTLY_CFG);

      // Slider + primera generación
      const slider = $('#slider-'+id), genLbl = $('#gen-'+id);
      slider.max = frames.length-1; slider.value = 0; genLbl.textContent = 1;
      slider.addEventListener('input', ()=>{
        const i = parseInt(slider.value,10);
        currentGenIndex[inst] = i;              // ← guarda la gen actual
        genLbl.textContent = i+1;
        showGenInCard(inst, id, i);
      });


      // Primer render
      showGenInCard(inst, id, 0);
      observeCardResize(id);
    }

    function showGenInCard(inst, id, index){
      const frames = framesPerInst[inst]; if(!frames) return;
      const points = frames[index] || [];

      const hasFlag = points.every(p=>typeof p.isPareto==='boolean');
      const allPoints = hasFlag ? points : findParetoFront(points);
      const pareto = allPoints.filter(p=>p.isPareto);
      const dom = allPoints.filter(p=>!p.isPareto);

      const layout = {
        title:`Frente – Gen ${index+1}`,
        xaxis:{title:'f1'}, yaxis:{title:'f2'},
        paper_bgcolor:'#fff', plot_bgcolor:'#fff',
        hovermode:'closest'
      };

      const el = document.getElementById('plot-' + id);
      const dataTraces = [
        {
          x: dom.map(p=>p.x), y: dom.map(p=>p.y),
          customdata: dom.map(p=>p.ids),
          text: dom.map(mkHoverTextPt),
          mode:'markers', marker:{size:8, color:'blue'}, name:'Dominados',
          hovertemplate: '%{text}<extra></extra>',
          hoverlabel: { align:'left', namelength: 0 }
        },
        {
          x: pareto.map(p=>p.x), y: pareto.map(p=>p.y),
          customdata: pareto.map(p=>p.ids),
          text: pareto.map(mkHoverTextPt),
          mode:'markers', marker:{size:10, color:'red', symbol:'circle-open'}, name:'Pareto',
          hovertemplate: '%{text}<extra></extra>',
          hoverlabel: { align:'left', namelength: 0 }
        }
      ];

      const plotPromise = el.data
        ? Plotly.react(el, dataTraces, layout)
        : Plotly.newPlot(el, dataTraces, layout, { responsive:true, displayModeBar:false });

      plotPromise.then(gd => {
        gd.removeAllListeners?.('plotly_click');
        gd.on('plotly_click', async d => {
          const idsSel = d.points[0].customdata || [];
          lastSelPerInst[inst] = idsSel;

          // Panel de detalle bajo la card
          const coord = `(${(+d.points[0].x).toFixed(2)}, ${( +d.points[0].y).toFixed(2)})`;

          // Mapa (como ya lo tenías)
          const res = await fetch('/map', {
            method:'POST', headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ instancia: inst, ids: idsSel, show_probs: selProbAll.checked, x: d.points[0].x, y: d.points[0].y })
          });
          if (res.ok) {
            const { img, stats } = await res.json();
            const imgEl = $('#map-'+id), stEl = $('#stats-'+id);
            imgEl.src = 'data:image/png;base64,' + img; imgEl.style.display = 'block';
            stEl.textContent = stats; stEl.style.display = 'block';
          }
        });
      });
    }

    
    function observeCardResize(id){
      const card = document.getElementById('card-'+id);
      if (!window.ResizeObserver || !card) return;
      let rafId = null;
      const ro = new ResizeObserver(() => {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(() => {
          const p  = document.getElementById('plot-'+id);
          const hv = document.getElementById('hv-'+id);
          const hi = document.getElementById('hist-'+id);
          if (p)  Plotly.Plots.resize(p);
          if (hv) Plotly.Plots.resize(hv);
          if (hi) Plotly.Plots.resize(hi);
          rafId = null;
        });
      });
      ro.observe(card);
    }



    selProbAll.addEventListener('change', async ()=>{
      for (const inst of Object.keys(lastSelPerInst)) {
        const ids = lastSelPerInst[inst];
        const id = slug(inst);
        const res = await fetch('/map',{
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ instancia: inst, ids, show_probs: selProbAll.checked })
        });
        if(res.ok){
          const {img, stats} = await res.json();
          const imgEl = $('#map-'+id), stEl = $('#stats-'+id);
          if(imgEl){ imgEl.src = 'data:image/png;base64,'+img; imgEl.style.display='block'; }
          if(stEl){ stEl.textContent = stats; stEl.style.display='block'; }
        }
      }
    });

    window.addEventListener('resize', ()=>{
      document.querySelectorAll('.js-plotly-plot')
        .forEach(el => Plotly.Plots.resize(el));
    });

    fixScaleAll?.addEventListener('change', ()=>{
      for (const inst of Object.keys(framesPerInst)) {
        const id = slug(inst);
        const i  = currentGenIndex[inst] ?? 0;
        showGenInCard(inst, id, i);
      }
    });

    function renderInteractiveMap(targetDivId, jsonData) {
      if (!jsonData) return;

      const {meta, demanda, preinstalados_movidos_origen, seleccionados_nuevos, seleccionados_existentes, coords_finales_aeds} = jsonData;
    
      const traces = [
        // 1. Puntos de Demanda OHCA
        {
          x: demanda.x, y: demanda.y,
          mode:'markers', name:'Nodos de demanda',
          marker: {size: demanda.s.map(s => Math.sqrt(s)), color:'blue', opacity:0.6}
        },
        // 2. Origen de AEDs preinstalados movidos
        {
          x: preinstalados_movidos_origen.x, y: preinstalados_movidos_origen.y,
          mode:'markers', name:'AED movido',
          marker: {size: preinstalados_movidos_origen.s.map(s => Math.sqrt(s)), color:'red', opacity:0.8, symbol:'circle-open', line: {width:2}}
        },
        // 3. AEDs preinstalados que se mantuvieron
        {
          x: seleccionados_existentes.x, y: seleccionados_existentes.y,
          mode:'markers', name:'Equipo Preinstalado (Mantenido)',
          marker: {size: 14, color:'orange', symbol: "star", line: {width:1, color:'black'}}
        },
        // 4. Nuevos AEDs instalados
        {
          x: seleccionados_nuevos.x, y: seleccionados_nuevos.y,
          mode:'markers', name:'AED instalado (Nuevo)',
          marker: {size: 14, color:'green', symbol: "star", line: {width:1, color:'black'}}
        }
      ];

      const shapes = [];
      
      for (const coords of coords_finales_aeds) {
        const x = coords[0];
        const y = coords[1];
        shapes.push({
          type: 'circle',
          xref: 'x', yref: 'y',
          x0: x - meta.radio, y0: y - meta.radio,
          x1: x + meta.radio, y1: y + meta.radio,
          fillcolor: 'rgba(128, 128, 128, 0.15)',
          line: { color: 'rgba(128, 128, 128, 0.3)' },
        });
      }

      const layout = {
        title: `Mapa Interactivo: ${meta.instancia}`,
        xaxis: { title: 'Coordenada X', scaleanchor: 'y', scaleratio: 1 },
        yaxis: { title: 'Coordenada Y' },
        shapes: shapes,
        legend: { x:1.02, y:1 },
        hovermode: 'closest'
      };
      Plotly.newPlot(targetDivId, traces, layout, {responsive:true, displayModeBar:true});
    }

    const btnToggleMap = $('#btn-toggle-map');
    const mapImgContainer = $('#map-image-container');
    const mapPlotContainer = $('#map-plot-container');

    btnToggleMap.addEventListener('click', () => {
        const isStaticVisible = !mapImgContainer.classList.contains('hidden');

        if (isStaticVisible) {
            // Si el estático está visible, lo ocultamos y mostramos el interactivo
            mapImgContainer.classList.add('hidden');
            mapPlotContainer.classList.remove('hidden');
            btnToggleMap.textContent = 'Ver mapa estático';
            Plotly.Plots.resize('map-plot'); // Asegura que el plot se redimensione correctamente
        } else {
            // Si el interactivo está visible, lo ocultamos y mostramos el estático
            mapPlotContainer.classList.add('hidden');
            mapImgContainer.classList.remove('hidden');
            btnToggleMap.textContent = 'Ver mapa interactivo';
        }
    });
  </script>
</body>
</html>
