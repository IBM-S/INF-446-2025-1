<!-- Puedes copiar el HTML completo desde aquí: -->
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Visualizador MOEA/D</title>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
    form { margin-bottom: 20px; }
    #plot, #hv-plot, #history-plot { width: 90%; margin: auto; }
    #plot { height: 600px; }
    #hv-plot { height: 400px; margin-top: 40px; }
    #history-plot { height: 500px; margin-top: 40px; }
    #slider-container { margin-top: 20px; width: 80%; margin-left: auto; margin-right: auto; }
    #slider { width: 100%; }
    button, label { margin: 5px; padding: 8px 15px; }
  </style>
</head>
<body>
  <h1>Visualizador MOEA/D</h1>
    <form id="form">
    <div style="margin-bottom: 10px;">
      <label style="margin-right: 10px;">Instancia:
        <select name="instancia" style="margin-right: 20px;">
          <option value="DRP.dat">DRP.dat</option>
          <option value="100-3.dat">100-3.dat</option>
          <option value="150-11.dat">150-11.dat</option>  
          <option value="1000-88_4.dat">1000-88_4.dat</option>
          <option value="1450-71_4.dat">1450-71_4.dat</option>
        </select>
      </label>

      <label style="margin-right: 10px;">Semilla:
        <input name="semilla" value="123" style="margin-right: 20px;">
      </label>

      <label style="margin-right: 10px;">Variables:
        <select name="num_var" style="margin-right: 20px;">
          <option value="21">21</option>
          <option value="100">100</option>  
          <option value="150">150</option>
          <option value="1000">1000</option>
          <option value="1450">1450</option>
        </select>
      </label>

      <button type="submit">Ejecutar</button>
    </div>
  </form>


  <button id="load-btn">Cargar generaciones existentes</button>
  <label><input type="checkbox" id="fix-scale"> Usar la misma escala para comparar</label>
  <label><input type="checkbox" id="recalcular-hv" checked>Recalcular hipervolumen al cargar</label>

  <h3 id="status">Esperando ejecución...</h3>


  <div id="pareto-map-wrapper" style="display: flex; justify-content: center; align-items: flex-start; gap: 20px; margin-top: 20px;">
  <div id="plot" style="width: 60%; min-width: 400px;"></div>
  <div id="map-container" style="display: none; width: 40%; min-width: 300px;">
    <h3>Configuración seleccionada:</h3>
    <img id="map-image" src="" alt="Mapa" style="width: 100%; border: 1px solid #ccc;">
  </div>
  </div>

  <div id="stats-container" style="white-space: pre; text-align:left; font-family: monospace; margin-top:10px; display:none;"></div>

    <div id="slider-container" style="display:none;">
    <input type="range" id="slider" min="0" max="0" value="0">
    <p>Generación: <span id="gen-num">1</span></p>
  </div>

  <div id="hv-plot"></div>
  <div id="history-plot"></div>


    <script>
    const form = document.getElementById("form");
    const status = document.getElementById("status");
    const plotDiv = document.getElementById("plot");
    const sliderContainer = document.getElementById("slider-container");
    const slider = document.getElementById("slider");
    const genNum = document.getElementById("gen-num");
    const loadBtn = document.getElementById("load-btn");
    const fixScaleCheckbox = document.getElementById("fix-scale");

    let frames = [];
    let hvValues = [];
    let globalXMin = Infinity, globalXMax = -Infinity;
    let globalYMin = Infinity, globalYMax = -Infinity;

    function findParetoFront(points) {
      if (!points || !Array.isArray(points) || points.length === 0) return [];
      const isDominated = new Array(points.length).fill(false);
      for (let i = 0; i < points.length; i++) {
        for (let j = 0; j < points.length; j++) {
          if (i !== j) {
            if (points[j].x <= points[i].x && points[j].y <= points[i].y &&
                (points[j].x < points[i].x || points[j].y < points[i].y)) {
              isDominated[i] = true;
              break;
            }
          }
        }
      }
      return points.map((p, i) => ({ ...p, isPareto: !isDominated[i] }));
    }

    function getMultiColor(factor) {
      const gradientColors = ["#440154", "#3b528b", "#21918c", "#fde725", "#ff7f00"];
      const scaled = factor * (gradientColors.length - 1);
      const idx1 = Math.floor(scaled);
      const idx2 = Math.min(idx1 + 1, gradientColors.length - 1);
      const localFactor = scaled - idx1;
      const c1 = gradientColors[idx1].slice(1);
      const c2 = gradientColors[idx2].slice(1);
      const r1 = parseInt(c1.slice(0, 2), 16), g1 = parseInt(c1.slice(2, 4), 16), b1 = parseInt(c1.slice(4), 16);
      const r2 = parseInt(c2.slice(0, 2), 16), g2 = parseInt(c2.slice(2, 4), 16), b2 = parseInt(c2.slice(4), 16);
      const r = Math.round(r1 + localFactor * (r2 - r1));
      const g = Math.round(g1 + localFactor * (g2 - g1));
      const b = Math.round(b1 + localFactor * (b2 - b1));
      return `rgb(${r},${g},${b})`;
    }

    async function loadGenerations(files, hvs) {
      frames = [];
      hvValues = hvs;
      globalXMin = Infinity; globalXMax = -Infinity;
      globalYMin = Infinity; globalYMax = -Infinity;

      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const res = await fetch("/get/" + file);
        const text = await res.text();

        // Formatos soportados (línea):
        //  - 'x y P ids...' / 'x y D ids...'
        //  - 'x y - IDs instalados: ...'
        //  - 'x y ids...'
        const puntos = text
          .trim()
          .split("\n")
          .map(l => l.trim())
          .filter(l => l && !l.startsWith("#"))
          .map(line => {
            const toks = line.split(/\s+/);
            const f1 = parseFloat(toks[0]);
            const f2 = parseFloat(toks[1]);

            let startIdx = 2;
            let isPareto; // undefined si no viene bandera
            if (Number.isNaN(parseFloat(toks[2]))) {
              // tercer token NO es número => puede ser P/D o "-".
              if (toks[2] === "P") { isPareto = true;  startIdx = 3; }
              else if (toks[2] === "D") { isPareto = false; startIdx = 3; }
              else if (toks[2] === "-" && line.includes("IDs instalados:")) {
                const right = line.split("IDs instalados:")[1] || "";
                const ids = right.trim().split(/\s+/).map(Number).filter(n => !Number.isNaN(n));
                updateRanges(f1, f2);
                return { x: f1, y: f2, ids, isPareto };
              }
            }

            const ids = toks.slice(startIdx).map(n => parseInt(n, 10)).filter(n => !Number.isNaN(n));
            updateRanges(f1, f2);
            return { x: f1, y: f2, ids, isPareto };
          });

        frames.push(puntos);
      }

      showGeneration(0);
      sliderContainer.style.display = "block";
      slider.max = frames.length - 1;
      slider.value = 0;
      genNum.innerText = 1;
      status.innerText = `Listo: ${frames.length} generaciones cargadas`;

      Plotly.newPlot("hv-plot", [{
        x: hvValues.map((_, i) => i + 1),
        y: hvValues,
        mode: "lines+markers",
        marker: { color: "green" },
        line: { color: "green" },
        name: "Hipervolumen"
      }], {
        title: "Evolución del Hipervolumen",
        xaxis: { title: "Generación" },
        yaxis: { title: "Hipervolumen" }
      });

      document.getElementById("hv-plot").on("plotly_click", function(data) {
        const gen = data.points[0].x;
        slider.value = gen - 1;
        genNum.innerText = gen;
        showGeneration(gen - 1);
      });

      // Historial de frentes (solo Pareto por generación)
      const traces = frames.map((points, idx) => {
        const hasFlag = points.every(p => typeof p.isPareto === "boolean");
        const allPoints = hasFlag ? points : findParetoFront(points);
        const paretoPoints = allPoints.filter(p => p.isPareto);
        const color = getMultiColor(idx / Math.max(1, (frames.length - 1)));
        return {
          x: paretoPoints.map(p => p.x),
          y: paretoPoints.map(p => p.y),
          mode: "markers",
          marker: { size: 6, color: color },
          name: `Gen ${idx + 1}`,
          showlegend: false
        };
      });

      Plotly.newPlot("history-plot", traces, {
        title: "Historial de Frentes de Pareto",
        xaxis: { title: "f1" },
        yaxis: { title: "f2" }
      });

      function updateRanges(f1, f2) {
        if (f1 < globalXMin) globalXMin = f1;
        if (f1 > globalXMax) globalXMax = f1;
        if (f2 < globalYMin) globalYMin = f2;
        if (f2 > globalYMax) globalYMax = f2;
      }
    }

    function showGeneration(index) {
      const points = frames[index];
      if (!points || !Array.isArray(points)) return;

      // Si el archivo trae banderas P/D, úsalo; si no, calcula
      const hasFlag = points.every(p => typeof p.isPareto === "boolean");
      const allPoints = hasFlag ? points : findParetoFront(points);

      const paretoPoints = allPoints.filter(p => p.isPareto);
      const dominatedPoints = allPoints.filter(p => !p.isPareto);

      const layout = {
        title: `Frente de Pareto - Generación ${index + 1}`,
        xaxis: { title: "Minimizar Cobertura Probabilística (f1)" },
        yaxis: { title: "Minimizar Costos (f2)" },
        legend: {
          x: 1, y: 1, xanchor: 'right', yanchor: 'top',
          bgcolor: 'rgba(255,255,255,0.8)', bordercolor: '#ccc', borderwidth: 1
        }
      };

      if (fixScaleCheckbox.checked) {
        const xMargin = (globalXMax - globalXMin) * 0.05;
        const yMargin = (globalYMax - globalYMin) * 0.05;
        layout.xaxis.range = [globalXMin - xMargin, globalXMax + xMargin];
        layout.yaxis.range = [globalYMin - yMargin, globalYMax + yMargin];
      }

      Plotly.react(plotDiv, [
        {
          x: dominatedPoints.map(p => p.x),
          y: dominatedPoints.map(p => p.y),
          text: dominatedPoints.map(p => `IDs: ${p.ids.join(", ")}`),
          customdata: dominatedPoints.map(p => p.ids),
          mode: "markers",
          marker: { size: 8, color: "blue" },
          name: "Dominados",
          showlegend: true
        },
        {
          x: paretoPoints.map(p => p.x),
          y: paretoPoints.map(p => p.y),
          text: paretoPoints.map(p => `IDs: ${p.ids.join(", ")}`),
          customdata: paretoPoints.map(p => p.ids),
          mode: "markers",
          marker: { size: 10, color: "red", symbol: "circle-open" },
          name: "Frente Pareto",
          showlegend: true
        }
      ], layout);

      plotDiv.removeAllListeners?.('plotly_click');
      plotDiv.on('plotly_click', async function(data) {
        const idsSeleccionados = data.points[0].customdata || [];
        const instanciaActual = form.instancia.value;

        const res = await fetch("/map", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ instancia: instanciaActual, ids: idsSeleccionados })
        });

        if (res.ok) {
          const json = await res.json();
          const imgURL = "data:image/png;base64," + json.img;

          document.getElementById("map-image").src = imgURL;
          document.getElementById("map-container").style.display = "block";

          const statsDiv = document.getElementById("stats-container");
          statsDiv.textContent = json.stats;
          statsDiv.style.display = "block";
        } else {
          alert("❌ No se pudo generar el mapa.");
        }
      });
    }

    slider.addEventListener("input", () => {
      const index = parseInt(slider.value);
      genNum.innerText = index + 1;
      showGeneration(index);
    });

    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      status.innerText = "Ejecutando MOEA/D...";
      const data = {
        instancia: form.instancia.value,
        semilla: form.semilla.value,
        num_var: form.num_var.value
      };
      const res = await fetch("/run", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data)
      });
      const json = await res.json();
      if (!json.files || json.files.length === 0) {
        status.innerText = "⚠️ No se generaron archivos.";
        return;
      }
      await loadGenerations(json.files, json.hv || []);
    });

    loadBtn.addEventListener("click", async () => {
      status.innerText = "Cargando generaciones existentes...";
      const data = {
        instancia: form.instancia.value,
        semilla: form.semilla.value,
        recalcular: document.getElementById("recalcular-hv").checked
      };
      const res = await fetch("/load", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data)
      });
      const json = await res.json();
      if (!json.files || json.files.length === 0) {
        status.innerText = "⚠️ No se encontraron generaciones guardadas.";
        return;
      }
      await loadGenerations(json.files, json.hv || []);
    });

    fixScaleCheckbox.addEventListener("change", () => {
      showGeneration(parseInt(slider.value));
    });
  </script>
</body>
</html>