# ===================== DRP_Reubicacion.run =====================

reset;

model mo_relocation_model.mod;
data  DRP_con_probs.dat;
data casos_dats_prob/150-11.dat;
# data casos_dats_prob/alcaldia_milpa_alta.dat;
# ---------- Config ----------
param mostrar_pesos default 1;

# Solver
option solver "./gurobi";
option gurobi_options 'timelim = 60';
option show_stats 1;
option solver_msg 0;

printf "\n--- MODO: REUBICACIoN FLEXIBLE ---\n";
printf "Instancia: %s\n", nombre_instancia;
printf "Presupuesto P = %g, Radio R = %g\n\n", P, R;

# ---------- Parametros para guardar resultados ----------
param Ttotal default 0;

param TCPU1 {objetivos}   default 0;
param MVF   {objetivos}   default 0;
param PVF   {objetivos}   default 0;
param f1    {objetivos}   default 0;

param f2    {objetivos}   default 0;
param TCPU2 {ejecuciones} default 0;
param FN1   {ejecuciones} default 0;
param FN2   {ejecuciones} default 0;
param F1    {ejecuciones} default 0;
param F2    {ejecuciones} default 0;
param BT1   {ejecuciones} default 0;
param BT2   {ejecuciones} default 0;

param Tstartuno default 0;
param Tstartdos default 0;

# Tabla de extremos (payoff)
param SolucionExtrema {objetivos, objetivos};

# ---------- Helpers impresiones ----------
# Presencia final (solo para impresion; no crea var nueva)
# y[i] := w[i] + x[i] + sum_k t[k,i]
# Costo usado (debe coincidir con F[2])
# cost_used := sum_i x[i]*c1 + sum_i (1-w[i])*flag[i]*c2
# Cobertura (prob): -F[1] = sum_j z[j]*prob_ohca[j]
# Una rutina de impresion compacta para una solucion actual
# (la llamaremos despues de cada solve)
printf "\n";

# ############################################################################################
# ############################# FASE 1: Busqueda del mejor y peor valor ######################
# ############################################################################################

let Tstartuno := time() ;

for {gg in objetivos: time() - Tstartuno <= 30} {
    printf "\n--- Calculando extremo para Objetivo %d ---\n", gg;
    let g := gg;
    objective FO1;
    let Ttotal := time();
    solve;
    let TCPU1[gg] := time() - Ttotal;
    # Guarda vector F en la matriz de extremos
    for {i in objetivos} { let SolucionExtrema[gg, i] := F[i]; }
    let f1[gg] := F[1];
    let f2[gg] := F[2];
    printf "  F[1] (Cobert.) = %g   F[2] (Costo) = %g\n", F[1], F[2];
    # ------ Detalle de la solucion extrema ------
    printf "  >> COSTO USADO (debe = F[2]): ";
    printf "%g\n", (sum{i in N} x[i]*c1) + (sum{i in N} (1 - w[i])*flag[i]*c2);
    printf "  >> COBERTURA PROB. (debe = -F[1]): ";
    printf "%g\n", sum{j in N} z[j]*prob_ohca[j];
    printf "\n  -------- EXISTENTES (flag=1) --------\n";
    for {i in N: flag[i]=1 && w[i]=1} {
        printf "    - Se mantiene el AED original en i=%d\n", i;
    }
    for {i in N: flag[i]=1 && w[i]=0} {
        printf "    - AED originalmente en i=%d fue MOVIDO a: ", i;
        for {j in N: t[i,j]=1} { printf "j=%d ", j; }
        printf "\n";
    }
    printf "\n  -------- INSTALACIONES NUEVAS --------\n";
    for {i in N: x[i]=1} {
        printf "    - Se instala NUEVO AED en i=%d\n", i;
    }
    printf "\n  -------- PRESENCIA FINAL y[i]=1 --------\n";
    for {i in N: (w[i]+x[i]+sum{k in N} t[k,i]) >= 0.5} {
        printf "    - Al final hay AED en i=%d (y=1)\n", i;
    }
    printf "\n  -------- COBERTURA (z[j]=1) --------\n";
    printf "    j cubiertos: ";
    for {j in N: z[j]=1} { printf "%d ", j; }
    printf "\n\n";
    # Limpieza para proximo extremo
    reset data w, t, x, z, F;
}
# Determinar MV y PV por columna a partir de SolucionExtrema
for {i in objetivos} {
    let MV[i] := min {gg in objetivos} SolucionExtrema[gg, i];
    let PV[i] := max {gg in objetivos} SolucionExtrema[gg, i];
    let MVF[i] := MV[i];
    let PVF[i] := PV[i];
}


# ############################################################################################
# ############################# FASE 2: Busqueda de la frontera de Pareto ####################
# ############################################################################################

let Tstartdos := time() ;

for {gg in ejecuciones: time() - Tstartdos <= 30} {
    printf "\n==> Ejecucion ponderada %d\n", gg;
    for {i in objetivos} { let betha[i] := sigma[gg,i]; }
    objective FO2;
    let Ttotal := time();
    solve;
    let TCPU2[gg] := time() - Ttotal;
    # Guardar resultados agregados
    let F1[gg] := F[1];
    let F2[gg] := F[2];
    let BT1[gg] := sigma[gg,1];
    let BT2[gg] := sigma[gg,2];
    if (MV[1] - PV[1]) <> 0 then { let FN1[gg] := (F[1] - PV[1]) / (MV[1] - PV[1]); } else { let FN1[gg] := 0; }
    if (MV[2] - PV[2]) <> 0 then { let FN2[gg] := (F[2] - PV[2]) / (MV[2] - PV[2]); } else { let FN2[gg] := 0; }
    # ------ Detalle de la solucion de compromiso ------
    printf "  F[1] (Cobert.) = %g   F[2] (Costo) = %g   (BT1=%g, BT2=%g)\n", F[1], F[2], BT1[gg], BT2[gg];
    printf "  >> COSTO USADO: %g\n", (sum{i in N} x[i]*c1) + (sum{i in N} (1 - w[i])*flag[i]*c2);
    printf "  >> COBERTURA PROB.: %g\n", sum{j in N} z[j]*prob_ohca[j];
    printf "\n  -------- EXISTENTES (flag=1) --------\n";
    for {i in N: flag[i]=1 && w[i]=1} {
        printf "    - Se mantiene el AED original en i=%d\n", i;
    }
    for {i in N: flag[i]=1 && w[i]=0} {
        printf "    - AED originalmente en i=%d fue MOVIDO a: ", i;
        for {j in N: t[i,j]=1} { printf "j=%d ", j; }
        printf "\n";
    }
    printf "\n  -------- INSTALACIONES NUEVAS --------\n";
    for {i in N: x[i]=1} {
        printf "    - Se instala NUEVO AED en i=%d\n", i;
    }
    printf "\n  -------- PRESENCIA FINAL y[i]=1 --------\n";
    for {i in N: (w[i]+x[i]+sum{k in N} t[k,i]) >= 0.5} {
        printf "    - Al final hay AED en i=%d (y=1)\n", i;
    }
    printf "\n  -------- COBERTURA (z[j]=1) --------\n";
    printf "    j cubiertos: ";
    for {j in N: z[j]=1} { printf "%d ", j; }
    printf "\n\n";
    # Limpieza para la proxima corrida ponderada
    reset data w, t, x, z, F;
}
# ============ RESUMEN FINAL ============
printf "\n\n================== RESUMEN FINAL ==================\n";
printf "\nValores extremos encontrados (Payoff Table):\n";
printf "%-10s | %-12s | %-12s | %-12s | %-12s | %-12s\n",
       "Objetivo","MVF (Mejor)","PVF (Peor)","TCPU1 (s)","f1 (Cobert.)","f2 (Costo)";
printf "%s\n", "-----------+--------------+--------------+--------------+--------------+---------------";
for {i in objetivos} {
    printf "%-10g | %-12g | %-12g | %-12g | %-12g | %-12g\n", i, MVF[i], PVF[i], TCPU1[i], f1[i], f2[i];
}
printf "\nResultados de las ejecuciones ponderadas:\n";
if mostrar_pesos = 1 then {
    printf "%-10s : %-10s | %-10s | %-10s | %-10s | %-12s | %-12s | %-10s\n",
           "Ejecucion","BT1","BT2","FN1","FN2","F1 (Cobert.)","F2 (Costo)","TCPU2 (s)";
    printf "%s\n", "-----------:------------+------------+------------+------------+--------------+--------------+------------";
    for {gg in ejecuciones} {
        printf "%-10g : %-10.3g | %-10.3g | %-10.4g | %-10.4g | %-12.4g | %-12.4g | %-10g\n",
               gg, BT1[gg], BT2[gg], FN1[gg], FN2[gg], F1[gg], F2[gg], TCPU2[gg];
    }
} else {
    printf "%-10s : %-12s | %-12s | %-12s | %-12s | %-12s\n",
           "Ejecucion","FN1","FN2","F1 (Cobert.)","F2 (Costo)","TCPU2 (s)";
    printf "%s\n", "-----------:--------------+--------------+--------------+--------------+---------------";
    for {gg in ejecuciones} {
        printf "%-10g : %-12.6g | %-12.4g | %-12.4g | %-12.4g | %-12g\n",
               gg, FN1[gg], FN2[gg], F1[gg], F2[gg], TCPU2[gg];
    }
}
printf "================================================================================================\n";
# =================== fin ===================
 